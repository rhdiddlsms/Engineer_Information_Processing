# 서버 프로그램 구현
# 1. 개발 환경 구축

## 개발 도구 분류

- 구현 도구 : 코드 작성과 디버깅 및 수정 작업

- 테스트 도구 : 코드의 기능과 품질 향상 ( xUnit, PMD, Findbugs, Cppcheck, Sonar )

- 형상관리 도구 : 코드와 산출물에 대한 버전 관리

- 빌드 도구 : 코드의 빌드와 배포 수행 ( Gradle, Maven, Ant )

## 서버 하드웨어 개발 환경

- Client
  - Client 하드웨어 개발 환경
- Web Server
  - 웹상의 정적 콘텐츠
  - HTTP를 이용한 요청/응답
- WAS
  - 동적 콘텐츠
- DB(데이터 베이스)
  - 데이터 수집 및 관리

## 소프트웨어 개발 환경

- 운영체제
  - 하드웨어와 사용자 인터페이스
- 미들웨어
  - 컴퓨터와 컴퓨터를 연결
  - 쉽고 안전하게 프로그램 사용
- DBMS
  - 사용자 DB 사이 위치

## JVM

시스템 메모리를 관리하고 자바 기반 Application을 위해 실행 환경 제공

## 형상관리(SCM; Software Configuration Management) (2020 실기 2회 기출문제 - 단답형)

- 소프트웨어의 개발 과정에서 `소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동`

- 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보

- 형상 관리는 소프트웨어 `개발의 전 단계에 적용되는 활동`이며, 유지보수 단계에서도 수행

- 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 함

### 형상 관리 기능의 종류

- `형상 식별`
- `버전 제어`
- `형상 통제`
- `형상 감사`
- `형상 기록`

- 형상 식별
  - 형상 관리 대상에 이름과 관리 번호를 부여하고, `계층(Tree) 구조로 구분`하여 수정 및 추적이 용이하도록 함
- 버전 제어
  - 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 `특정 절차와 도구(Tool)를 결합`시키는 작업
- 형상 통제(변경 관리)
  - 식별된 형상 항목에 대한 변경 요구를 검토하여 `현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정`하는 작업
- 형상 감사
  - 기준선의 `무결성을 평가하기 위해` 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- 형상 기록(상태 보고)
  - 형상의 식별, 통제, 감사 작업의 결과를 기록 관리하고 보고서를 작성하는 작업

# 2. 공통 모듈 구현

## 모듈(서술형)

하나의 소프트웨어 또는 하드웨어 단위

- 소프트웨어 설계에서 기능 단위로 분해하여 추상화되어 재사용 및 공유가 가능한 단위

## 모듈화(서술형)

모듈을 통해 소프트웨어의 성능을 향상시키고 디버깅, 수정, 통합을 용이하게 하는 설계 기법

## 공통 모듈

기능을 분할하고 추상화하여 성능 향상 및 유지 보수를 효과적으로 하기 위한 공통 컴포넌트 구현 기법

- 공통 모듈 구현 비용
  - 모듈 개수 ↑ >> 통합 비용 ↑
  - 모듈 개수 ↓ >> 개발 비용 ↑
    - 공장에서 모듈(부품)생산할 때 모듈 개수가 많다면 인프라 구축으로 인해서 개발 비용은 별로 들지 않지만 통합적인 비용이 많이 들 수 있다. 반대로 공장에서 적은 모듈의 개수를 생산한다면 각각의 모듈에 대한 개발 비용이 들 수 있다.

## 결합도와 응집도

### 결합도 
상호의존의 정도, `결합도가 약해야 품질이 상승`
- 
- 결합도가 약한 순서 -> 강한 순서
`data` – `stamp` – `control` – `external` – `common` - `content`

`자스제외공내` (자스(잤으)니까 합격제외 공부는 나(내)처럼)

- 자료-데이터
- 스탬프-자료구조
- 제어-다른 모듈에서 흐름 파악
- 외부-참조
- 공통-공유되는
- 내용-직접참조,다른모듈에서 사용

- 자료
  - 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 `데이터`에 대한 처리 결과를 다시 돌려주는 방식
- 스탬프
  - 두 모듈이 동일한 `자료 구조`를 조회하는 경우
- 제어
  - 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우, `다른 모듈에서 흐름을 제어`
- 외부
  - 어떤 모듈에서 선언한 데이터를 `외부의 다른 모듈에서 참조`할 때
- 공통
  - `공유되는 공통 데이터 영역`을 여러 모듈이 사용할 때
- 내용
  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 `직접 참조하거나 수정`할 때
( 다른 모듈에서 사용하는 경우 )

### 응집도
정보은닉 개념 확장, `응집도가 강할수록 품질이 좋음`

- 응집도가 강한 순서 -> 약한 순서
`functional` – `sequential` – `communication` – `procedural` – `temporal` – `logical` – `coincidental`

기순교절시논우(기엽고 순진한 교회오빠는 절은 시러 노우)

- 기능적
  - 모듈 내부의 모든 기능 요소들이 `단일` 문제와 연관되어 수행될 경우
- 순차적
  - 모듈 내 하나의 활동으로부터 `나온 출력 데이터를 그 다음활동의 입력 데이터로 사용`할 경우
- 통신적(교환적)
  - `동일한 입출력을 사용하여 서로 다른 기능을 수행`하는 구성 요소들이 모였을 경우
- 절차적
  - 모듈이 `다수의 관련 기능`을 가질 때 모듈 안의 구성요소들이 그 기능을 `순차적으로 수행`할 경우
- 시간
  - `특정 시간에 처리`되는 몇 개의 기능을 모아 하나의 모듈로 작성한 경우
- 논리
  - `유사한 성격`을 갖거나 특정 형태로 분류되는 처리요소들이 하나의 모듈이 되는 경우
- 우연
  - 모듈 내부의 각 구성요소들이 `서로 관련 없는 요소`로만 구성된 경우


## 3. 공통 모듈 구현 절차

1. DTO/VO
   - DTO(Data Access Object) : 프로세스 사이에서 데이터 전송
   - VO(Value Object) : 고정 클래스가 가지는 Object
2. SQL
3. DAO(Data Transfer Object)
   - 특정 타입의 DB의 추상 인터페이스를 제공하는 객체
4. Service
5. Controller
6. View

## MVC 패턴

Model, View, Controller로 이루어진 패턴

### 생성 패턴(Creational Pattern)

`객체의 생성`과 관련된 패턴

- 추상 팩토리(Abstract Factory)
  - `동일한 주제의 다른 팩토리를 묶어줌`
  - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
- 빌더(Builder)
  - 생성과 표기를 분리해 복잡한 객체를 생성
- 팩토리 메소드(Factory Method)
  - `생성할 객체의 클래스를 국한하지 않고 객체를 생성`
  - 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
- 프로토타입(Prototype)
  - 기존 객체를 복제함으로써 객체를 생성
- 싱글톤(Singleton)
  - `한 클래스에 한 객체만 존재하도록 제한`
  - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴

### 구조 패턴(Structural Pattern)

클래스나 객체들을 `조합하여 더 큰 구조`로 만들 수 있게 해주는 패턴

- 어댑터(Adapter)
  - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움
- 브리지(Bridege)
  - 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있음
- 컴포지트(Composite)
  - `0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있음`
  - 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라리언트에서 구별없이 다루게 해주는 패턴
- 데코레이터(Decorator)
  - 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 할 수 있음
- 퍼싸드(Facade)
  - `많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공`
- 플라이웨이트(Flyweight)
  - 다수의 유사한 객체를 생성, 조작하는 비용을 절감할 수 있음
- 프록시(Proxy)
  - `접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공함`

### 행위 패턴(Behavioral Pattern)

클래스나 객체들이 `서로 상호작용하는 방법`이나 `책임 분배 방법을 정의`하는 패턴

- 책임 연쇄(Chain of Responsibility)
- 커맨드(Command)
  - **위의 명령어를 각각 구현하는 것보다는 위 그림처럼 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행하는 것**
  - 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 `재사용성이 높은 클래스를 설계`하는 패턴
- 인터프리터(Interpreter)
- 반복자(Iterator)
- 중재자(Mediator)
- 메멘토(Memento)
- 옵서버(Observer)
  - **어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 것**
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 패턴
- 상태(State)
- 전략(Strategy)
- 템플릿 메소드(Template Method)
  - **상위 클래스에서는 추상적으로 표현하고, 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴**
  - 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
- 방문자(Visitor)

# 4. 팬인 팬아웃(2020 실기 1회 기출문제)

소프트웨어의 구성 요소인 모듈을 계층적으로 분석하기 위해서 팬 인, 팬 아웃 활용

- 팬 인
  - 어떤 모듈을 제어하는 수, 해당 모듈로 들어오는 모듈의 수 (능동태 느낌)
- 팬 아웃
  - 어떤 모듈에 의해 제어되는 수, 해당 모듈에서 나가는 모듈의 수 (수동태 느낌)

## 공통 모듈 데스트

화이트 박스 테스트 // IDE 도구를 활용하여 디버깅 진행

### 화이트박스 검사

내부 소스코드를 확인하며 의도한 설계 흐름에 따라 코드가 실행되는지, 실행흐름에서 벗어나 불필요한 코드는 없는지 살펴봄 + 프로그램 로직을 이해하고 `내부 구조와 동작을 검사`하는 테스트 기법

### 블랙박스 검사

`내부 코드를 보지 않고` 사용자 요구사항 시점에서 기능이 잘 작동하는지 살펴봄 + 인터페이스 오류, `입력값에 목표 결과값이 나오는지 등을 봄 `

- `JUnit`
  - 자바 프로그래밍 언어용 단위 테스트 도구
- `어노테이션`
  - 주석을 달아 특별한 의미를 부여하는 메타데이터
- `Assert 메소드`
  - JUnit에서 가장 많이 이용되는 단정(Assert) 메소드
  - assertEquals(a, b) : 객체 a와 b가 일치함을 확인 (객체의 내용)
  - assertSame(a, b) : 객체 a와 b가 같은 객체임을 확인 (객체 자체)

 # 5. 배치 프로그램

사용자와 상호작용 없이 일련의 작업을 작업 단위로 묶어 `정기적으로 반복 수행하는 일괄 처리 방법`

## 배치 스케줄러 
일괄처리를 위해 주기적으로 발생시키는 작업 지원 도구

- 스프링 배치 
  - 대용량 처리를 제공하는 스케줄러
- 쿼츠 스케줄링
  - 플러그인을 통해 유연성을 제공하는 오픈 소스 기반 스케줄러
- Cron 표현식
  - 스케줄러를 실행시키기 위해 작업이 실행되는 주기를 설정하는 표현식
- 유형
  - `이벤트 배치`
  - `온디멘드 배치`
    - 사용자의 명시적 요구가 있을 때마다 실행하는 방법
  - `정기 배치`
    - 정해진 시점(주로 야간)에 실행하는 배치

## 배치 프로그램이 가지는 필수 요소

### 배치 프로그램 
컴퓨터 프로그램 흐름에 따라 순차적으로 자료를 처리하는 방식

- 초기의 배치프로그램 방식은 사용자와 상호작용하는 것이 불가능했지만, 운영체제가 발전함에 따라 프로그램 입출력을 통해 상호작용하는 것이 가능해짐
- 즉, 개별적으로 어떤 요청이 있을 때마다 실시간으로 통신하는 것이 아닌 한꺼번에 일괄적으로 대량 건을 처리하는 것
- 보통 정해진 특정한 시간에 실시함

- 사용하는 이유 
  - 업무의 효율성과 비효율적인 시스템의 과부하를 줄이기 위해서
- 대용량 데이터 
  - 대용량의 데이터를 처리할 수 있어야 함
- 자동화 
  - 심각한 오류 상황 외에는 사용자의 개입없이 동작해야 함
- 견고성 
  - 유효하지 않은 데이터의 경우도 처리해서 비정상적인 동작 중단이 발생하지 않아야 함
- 안정성 
  - 어떤 문제가 생겼는지 언제 발생했는지 등을 추적할 수 있어야 함
- 성능
  - 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 함